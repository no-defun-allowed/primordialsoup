Newspeak3
'Root'
class MirrorsForPrimordialSoup usingPlatform: platform internalKernel: ik namespace: ns (* :exemplar: platform mirrors *) = (|
private Collection = platform collections Collection.
private List = platform collections List.
private Map = platform collections Map.
private WeakMap = platform kernel WeakMap.
private StringBuilder = platform kernel StringBuilder.
private IdentityMap = ik IdentityMap.
private InstanceMixin = ik InstanceMixin.
private ClassMixin = ik ClassMixin.
private Metaclass = ik Metaclass.

private Activation = ik Activation.
private Closure = ik Closure.
private Message = ik Message.
private String = ik String.

private MetadataParsing = ns MetadataParsing.

private reflectees = WeakMap new.

private cachedPlatform = platform.
private internalKernel = ik.
private namespace = ns.
private parsingX
private intermediatesX
private compilerX
public metadataParsing = MetadataParsing usingPlatform: platform scannerClass: parsing Scanner.
|) (
public class ActivationMirror reflecting: activation thread: thr = (
(* :bogus: This constructor should not be public. *)
	|
	private reflectee <Activation> = activation.
	private thread <Thread> = thr.
	|
	reflectees at: self put: activation
) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfActivationMirror
)
public closure ^<ObjectMirror> = (
	| rawClosure = reflectee closure. |
	nil = rawClosure ifTrue: [^nil].
	^ObjectMirror reflecting: rawClosure
)
private compileExpression: expression <String> with: rawScope <Map[Symbol, Object]> ^<Method> = (
	| mixinMirror imethod |
	(* Super, outer and implicit receiver sends should behave like the expression is in the method class, not the receiver class. *)
	mixinMirror:: method definingMixin.
	imethod:: compiler
		compileExpressionSource: expression
		debugMapper: computeDebugMapper
		withScope: rawScope
		inMixin: mixinMirror.

	imethod methodMixin: reflectee method mixin.
	imethod source: expression.
	imethod debugInfo source: expression.
	^imethod compiledMethod metadata: imethod debugInfo
)
private computeDebugMapper = (
	^computeDebugInfo mapperForContext: reflectee
)
public enclosingActivation ^<ActivationMirror> = (
	| rawEnclosing = reflectee outerContext. |
	nil = rawEnclosing ifTrue: [^nil].
	^ActivationMirror reflecting: rawEnclosing thread: thread
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^(evaluateSuspended: expression) resume
)
public evaluate: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	^(evaluateSuspended: expression with: scope) resume
)
public evaluateSuspended: expression <String> ^<ThreadMirror> = (
	^evaluateSuspended: expression with: Map new
)
public evaluateSuspended: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	| rawScope expressionMethod thread simulator |
	rawScope:: Map new.
	scope keysAndValuesDo: [:key :value | rawScope at: key put: (reflectees at: value)].
	expressionMethod:: compileExpression: expression with: rawScope.

	simulator:: Simulator new.
	simulator activate: expressionMethod receiver: reflectee receiver arguments: {reflectee. rawScope}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
public isKindOfActivationMirror ^<Boolean> = (
	^true
)
public isUncontinuable ^<Boolean> = (
	^reflectee isDead
)
public method ^<MethorMirror> = (
	| rawMethod = reflectee method. definingMixin |

	(* Regular method / expression *)
	rawMethod isSynthetic ifFalse:
		  [^MethodMirror reflecting: rawMethod].

	rawMethod isLazySlotMethod ifTrue:
		  [^MethodMirror reflecting: rawMethod].		    

	(* :todo: These tests are complicated, and might also be wrong if the mixin was changed after this activation. Consider saving the relevant InstanceMixin in the synthetic method's metadata slot in the original compile instead. *)
	definingMixin:: rawMethod mixin.
	definingMixin isMeta ifFalse:
		[(* Nested class accessor *)
		 definingMixin _nestedMixins do:
			[:nestedMixin | nestedMixin _name = rawMethod selector ifTrue:
				[^SyntheticMethodMirror
					reflecting: rawMethod
					name: rawMethod selector
					source: nestedMixin _headerSource]].
		 (* Instance initializer *)
		 (isSubinitializerSelector: rawMethod selector) ifTrue:
			[^SyntheticMethodMirror
				reflecting: rawMethod
				name: definingMixin _primaryFactorySelector
				source: definingMixin _headerSource]].
	(* Factory *)
	definingMixin isMeta ifTrue:
		[definingMixin _instanceMixin _primaryFactorySelector = rawMethod selector ifTrue:
			[^SyntheticMethodMirror
				reflecting: rawMethod
				name: rawMethod selector
				source: definingMixin _instanceMixin _headerSource]].
	halt.)
private mxn: mixin = (
	nil = mixin ifTrue: [^nil].
	^MixinMirror reflecting: mixin
)
public operands ^<List[ObjectMirror]> = (
	(* todo: Should these simply appear in `slots` as slots with an empty or nil name? *)
	(* 'stack'? 'expression stack'? 'operand stack'? *)
	| closure numTemps result |
	closure:: reflectee closure.
	nil = closure
		ifTrue: [numTemps:: reflectee method numTemps]
		ifFalse: [numTemps:: closure numArgs + (numCopiedOf: closure)].
	result:: List new.
	numTemps + 1 to: reflectee size do:
		[:index | result add: (ObjectMirror reflecting: (reflectee tempAt: index))].
	^result
)
public receiver ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee receiver
)
public restart ^<ThreadMirror> = (
	thread restart: reflectee withLookup: false.
	^ThreadMirror reflecting: thread
)
public restartWithLookup ^<ThreadMirror> = (
	thread restart: reflectee withLookup: true.
	^ThreadMirror reflecting: thread
)
public return: result <ObjectMirror> ^<ThreadMirror> = (
	thread return: (reflectees at: result) from: reflectee.
	^ThreadMirror reflecting: thread
)
public sender ^<ActivationMirror> = (
	| rawSender = reflectee sender. |
	nil = rawSender ifTrue: [^nil].
	rawSender method primitive = 142 ifTrue: [^nil (* Hide simulation root. *)].
	^ActivationMirror reflecting: rawSender thread: thread
)
public slots ^<List[LocalSlotMirror]> = (
	| mapper = computeDebugMapper. result = List new. |
	mapper localNames do:
		[:localName |
		| localValue = mapper getValueOf: localName. |
		result add: (LocalSlotMirror name: localName value: (ObjectMirror reflecting: localValue))].
	^result
)
public sourceRange ^<Interval> = (
	(* The bci of an activation points to the bytecode that will be executed next. For the top activation, we want the source range to be this next action. For other activations, we want the source interval to be the pending message send. *)
	| effectiveBCI <Integer> range <Interval> |
	effectiveBCI:: reflectee bci.
	reflectee = thread suspendedActivation ifFalse:
		[effectiveBCI:: Simulator bciBefore: effectiveBCI in: reflectee method].
	range:: computeDebugInfo bciSourceMapping at: effectiveBCI ifAbsent: [^nil].
	range start = 0 ifTrue: [^nil].
	^range
)
public stepInto ^<ThreadMirror> = (
	thread stepInto: reflectee.
	^ThreadMirror reflecting: thread
)
public stepOut ^<ThreadMirror> = (
	thread stepOut: reflectee.
	^ThreadMirror reflecting: thread
)
public stepOver ^<ThreadMirror> = (
	thread stepOver: reflectee.
	^ThreadMirror reflecting: thread
)
public stepThrough ^<ThreadMirror> = (
	thread stepThrough: reflectee.
	^ThreadMirror reflecting: thread
)
private computeDebugInfo ^ <DebugInfo> = (
	| rawMethod <Method>  = reflectee method. metadata <String | LazySlotTag | DebugInfo | Nil> = rawMethod metadata. definingMixin <Mixin>  |

	(* Expression *)
	metadata isKindOfDebugInfo ifTrue:
		[^metadata].

	(* Regular method *)
	reflectee method isSynthetic ifFalse:
		[^(compiler compileMethodSource: reflectee method source within: method definingMixin) debugInfo].
   (* Lazy slot method *)
    reflectee method isLazySlotMethod ifTrue: [^(compiler compileLazySlotSource: reflectee method source within: method definingMixin) debugInfo].
    (* Other synthetic methods *)
	definingMixin:: rawMethod mixin.
	definingMixin isMeta ifFalse:
		[(* Nested class accessor *)
		 definingMixin _nestedMixins do:
			[:nestedMixin | nestedMixin _name = rawMethod selector ifTrue:
				[^(compiler
					compileClassHeader2: nestedMixin _headerSource
					within: (mxn: definingMixin)) accessor debugInfo]].
		 (* Instance initializer *)
		 (isSubinitializerSelector: rawMethod selector) ifTrue:
			[^(compiler
				compileClassHeader2: rawMethod mixin _headerSource
				within: (mxn: definingMixin _enclosingMixin)) initializers first debugInfo]].

	(* Factory *)
	definingMixin isMeta ifTrue:
		[definingMixin _instanceMixin _primaryFactorySelector = rawMethod selector ifTrue:
			[^(compiler
				compileClassHeader2: definingMixin _instanceMixin _headerSource
				within: (mxn: definingMixin _enclosingMixin)) factory debugInfo]].

	halt.
)
) : (
public invokeSuspended: closure <[]> ^ <ThreadMirror> = (
	| simulator thread |
	simulator:: Simulator new.
	simulator activateClosure: closure arguments: {}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public threadForBrokenActivation: a <Activation> reason: e <Exception> ^ <ThreadMirror> = (
  | thread = Thread new. |
  thread state: #broken.
  thread result: e.
  thread suspendedActivation: a.
  ^ThreadMirror reflecting: thread
)
)
public class AtomicInstallWrapper = (
) (
setMixinsOf: ir <IntermediateClassDeclaration> from: mxn <InstanceMixin> = (
   | mixinMap = Map new. |
   ir existingMixin: mxn.
   mxn _nestedMixins do: [:nm <InstanceMixin> | mixinMap at: nm _name put: nm].
   ir instanceSide nestedClasses do: [:ncir <IntermediateClassDeclaration > | 
	     | entry = mixinMap at: ncir simpleName ifAbsent: []. |
	     nil = entry ifFalse: [
		  setMixinsOf: ncir from: entry
		]
	].
)
installIRs: classDecls <List[IntermediateClassDeclaration]> into: ns <Map[Symbol, Object]> ^ <List[MixinMirror]> = (
  classDecls do: [:ir <IntermediateClassDeclaration> |  
	| entry = ns at: ir simpleName ifAbsent: []. |
      nil = entry ifFalse: [
	  entry isKindOfClass ifTrue: [setMixinsOf: ir from: (mixinOf: entry).]
	  ] 
  ].
  ^(AtomicInstaller new install: classDecls) collect: [:im <InstanceMixin> | MixinMirror reflecting: im]
)
public install: builders <List[ClassDeclarationBuilder]> into: ns = (
  | irs <List[IntermediateClassDeclaration]> =  
  (* Problem: Atomic install takes list of IRs. IR is not exposed by builder. Extract by brute force - mirrors are omnipotent! *)
     builders collect: [:b <ClassDeclarationBuilder> | ((ObjectMirror reflecting: b) getSlot: #intermediate) reflectee].
  |
  ^installIRs: irs into: ns
)
) : (
)
class AtomicInstaller = (|
private updateMixinsAndClasses <IdentityMap[OldObject,NewObject]>
private updateInstances <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
private newExistingMixins <Map[IntermediateClassDeclaration,InstanceMixin]>
|) (
allInstVarNamesOf: cls = (
	nil = cls ifTrue: [^{}].
	^(allInstVarNamesOf: (superclassOf: cls)) , ((mixinOf: cls) _slots collect: [:slotDesc | slotDesc at: 1])
)
private cleanup = (
	updateMixinsAndClasses: nil.
	updateInstances: nil.
	existingClasses: nil.
	newExistingMixins: nil.
)
private depthFor: klassArg <Class> ^<Integer> = (
	| klass depth |
	depth: 0.
	klass: klassArg.
	[nil = klass] whileFalse:
		[klass:: superclassOf: klass.
		depth: depth + 1].
	^depth
)
in: collection lastIndexOf: element = (
	collection size to: 1 by: -1 do: [:index | (collection at: index) = element ifTrue: [^index]].
	^0
)
public install: classDecls <List[IntermediateClassDeclaration]> = (
	| results |
	setup.
	results:: classDecls collect: [:classDecl | processClassDeclaration: classDecl].
	processExistingClasses.
	installAll.
	newExistingMixins keysAndValuesDo:
		[:classDecl :mixin | classDecl existingMixin: mixin].

	cleanup.

	^results (* <List[InstanceMixin]> *)
)
private installAll = (
	| updateCount oldObjects newObjects index |
	updateCount:: updateMixinsAndClasses size + updateInstances size.
	oldObjects:: Array new: updateCount.
	newObjects:: Array new: updateCount.
	index: 1.
	updateInstances keysAndValuesDo:
		[:old :new |
		oldObjects at: index put: old.
		newObjects at: index put: new.
		index: index + 1].
	(* Put updated mixins and classes last, so A -> C follows B -> C (see class comment). *)
	updateMixinsAndClasses keysAndValuesDo:
		[:old :new |
		oldObjects at: index put: old.
		newObjects at: index put: (updateInstances at: old ifAbsent: [new]). (* Follow B to avoid B -> C, A -> B. *)
		index: index + 1].
	updateCount = 0 ifTrue: [^self].
	elementsOf: oldObjects forwardIdentityToElementsOf: newObjects.
)
private layoutHasChangedBetween: oldClass <Behavior> and: newClass <Behavior> ^<Boolean> = (
	| oldCls newCls oldMixin newMixin oldSlots newSlots |
	oldCls:: oldClass.
	newCls:: newClass.
	[nil = oldCls] whileFalse:
		[oldMixin:: mixinOf: oldCls.
		 newMixin:: mixinOf: newCls.
		 oldMixin = newMixin ifFalse:
			[oldSlots:: oldMixin _slots.
			 newSlots:: newMixin _slots.
			 oldSlots size = newSlots size ifFalse: [^true].
			 1 to: oldSlots size do:
				[:index | ((oldSlots at: index) at: 1) = ((newSlots at: index) at: 1) ifFalse: [^true]]].
		 oldCls:: superclassOf: oldCls.
		 newCls:: superclassOf: newCls].
	^false
)
private methodDictionaryFor: mixin <AbstractMixin> from: imixin <IntermediateMixin> ^<MethodDictionary> = (
	| cmethods |
	cmethods:: imixin assembleMethods collect:
		[:imethod <IntermediateMethod> |
		imethod methodMixin: mixin.
		imethod compiledMethod].
	^cmethods asArray
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	| applications <WeakArray> |
	nil = existingMixin ifTrue: [^self].

	updateMixinsAndClasses at: existingMixin put: newMixin.
	updateMixinsAndClasses at: existingMixin _classMixin put: newMixin _classMixin.

	applications:: existingMixin _applications.
	nil = applications ifFalse:
		[applications do: [:application <Class> | sortClass: application]].
)
private processClassDeclaration: classDecl <IntermediateClassDeclaration> ^<InstanceMixin> = (
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	existingMixin <Mixin>
	nested
	|

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.

	mixin _headerSource: classDecl headerSource.
	mixin _accessModifier: classDecl accessModifier.
	mixin _primaryFactorySelector: classDecl factoryName.
	assert: [classDecl factoryName isNil not] message: 'Missing factory name'.
	mixin _name: classDecl simpleName.
	mixin _classMixin: classMixin.
	mixin _methods: (methodDictionaryFor: mixin from: classDecl instanceSide).
	mixin _slots: (classDecl instanceSide assembleSlots collect:
		[:s <IntermediateSlotDeclaration> | {s simpleName. s isMutable. s accessModifier}]) asArray.

	classMixin _instanceMixin: mixin.
	classMixin _methods: (methodDictionaryFor: classMixin from: classDecl classSide).

	existingMixin:: classDecl existingMixin.
	noteUpdateOf: existingMixin to: mixin.

	nil = existingMixin
		ifTrue:
		[newExistingMixins at: classDecl put: mixin]
		ifFalse:
		[(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin _enclosingMixin: existingMixin _enclosingMixin.
		mixin _classMixin _enclosingMixin: existingMixin _enclosingMixin].

	nested:: classDecl instanceSide nestedClasses collect:
		[:nestedClassDecl <IntermediateClassDeclaration> |
		| nestedMixin <InstanceMixin> |
		nestedMixin:: processClassDeclaration: nestedClassDecl.
		nestedMixin _enclosingMixin: mixin.
		nestedMixin _classMixin _enclosingMixin: mixin.
		nestedMixin].
	mixin _nestedMixins: nested asArray.
	^mixin
)
private processExistingClass: oldClass <Class> = (
	| oldSuperclass newSuperclass oldMixin newMixin oldEnclosingObject newClass |
	oldSuperclass:: superclassOf: oldClass.
	newSuperclass:: updateMixinsAndClasses at: oldSuperclass ifAbsent: [oldSuperclass].

	oldMixin:: mixinOf: oldClass.
	newMixin:: updateMixinsAndClasses at: oldMixin ifAbsent: [oldMixin].

	oldEnclosingObject:: enclosingObjectOf: oldClass.

	newClass:: newMixin
		apply: newSuperclass
		format: (nil = newSuperclass ifTrue: [0] ifFalse: [formatOf: newSuperclass])
		withName: newMixin _name
		enclosingObject: oldEnclosingObject.

	updateMixinsAndClasses at: oldClass putReplace: newClass.
	updateMixinsAndClasses at: (classOf: oldClass) put: (classOf: newClass).
)
private processExistingClasses = (
	| maxDepth ::= 0. |
	(* Process superclasses before subclasses. Create all new classes before remapping any instances. Remap instances in any order. *)
	existingClasses keysAndValuesDo:
		[:inheritanceDepth :classes |
		inheritanceDepth > maxDepth ifTrue:
			[maxDepth:: inheritanceDepth]].

	0 to: maxDepth do:
		[:inheritanceDepth |
		(existingClasses at: inheritanceDepth ifAbsent: [{}]) do:
			[:oldClass <Class> | processExistingClass: oldClass]].

	existingClasses keysAndValuesDo:
		[:inheritanceDepth :classes |
		classes do:
			[:oldClass <Class> | processInstancesOf: oldClass]].
)
private processInstancesOf: oldClass <Class> = (
	|
	newClass <Class> = updateMixinsAndClasses at: oldClass.
	oldSlotNames <Array[Symbol]>
	newSlotCount <Integer>
	remapIndices <Array[Integer]>
	|
	(layoutHasChangedBetween: oldClass and: newClass) ifFalse: [^self].

	(* Heuristic: choose the latter slot if a slot name is duplicated to favor overriding slots. *)
	oldSlotNames:: allInstVarNamesOf: oldClass.
	remapIndices:: (allInstVarNamesOf: newClass) collect:
		[:newSlotName | in: oldSlotNames lastIndexOf: newSlotName].
	newSlotCount:: remapIndices size.

	(* 'remapping with ' out.
	(((allInstVarNamesOf: oldClass) inject: '' into: [:a :b | a, ' ', b])
	, ' -> ',
	((allInstVarNamesOf: newClass) inject: '' into: [:a :b | a, ' ', b])) out.
	1 to: remapIndices size do: [:newIndex |
		(newIndex printString, '<-', (remapIndices at: newIndex) printString) out]. *)

	(allInstancesOf: oldClass) do:
		[:oldInstance |
		(* Avoid A -> D (see class comment). *)
		(updateMixinsAndClasses includesKey: oldInstance) ifFalse:
			[ | newInstance = allocate: newClass. |
			(* Copy state from oldInstance to newInstance. *)
			1 to: newSlotCount do: [:newIndex |
				| oldIndex value |
				oldIndex:: remapIndices at: newIndex.
				0 = oldIndex ifFalse: [
					value:: slotOf: oldInstance at: oldIndex.
					slotOf: newInstance at: newIndex put: value]].

			updateInstances at: oldInstance put: newInstance]].
)
private setup = (
	updateMixinsAndClasses:: IdentityMap new.
	updateInstances:: IdentityMap new.
	existingClasses:: IdentityMap new.
	newExistingMixins:: IdentityMap new. (* Regular Map okay here. *)
)
private sortClass: app <Class> = (
	| classes depth subclasses |

	(* InstanceMixin>>applications and Class>>subclasses are weak. *)
	nil = app ifTrue: [^self].

	(* We might see classes more than once because they appear both as an application of a changed mixin, and as a subclasses of a changed class. *)
	(updateMixinsAndClasses at: app ifAbsentPutVal: nil) ifFalse: [^self].

	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [List new].
	classes add: app.

	subclasses:: subclassesOf: app.
	nil = subclasses ifFalse:
		[subclasses do: [:subclass | sortClass: subclass]].
)
) : (
)
public class ClassDeclarationBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
public header <ClassHeaderBuilder> = ClassHeaderBuilder fromIntermediate: ir.
|) (
public accessModifier ^<Symbol> = (
	^intermediate accessModifier
)
public classSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate classSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public enclosingClass ^<ClassDeclarationBuilder> = (
	| enclosingIR enclosingNested enclosingBuilder |
	enclosingIR:: intermediate enclosingClass.
	nil = enclosingIR ifFalse:
		[^enclosingIR declaration builder].
	nil = intermediate existingMixin ifTrue:
		[intermediate isTopLevel ifFalse: [halt]. ^nil].
	nil = intermediate existingMixin _enclosingMixin ifTrue:
		[intermediate isTopLevel ifFalse: [halt]. ^nil].

	enclosingIR:: buildIntermediateFor: intermediate existingMixin _enclosingMixin within: nil.

	(* Patch up link *)
	intermediate enclosingClass: enclosingIR instanceSide.

	(* Patch down link and accessor. *)
	enclosingNested:: enclosingIR instanceSide nestedClasses.
	1 to: enclosingNested size do: [:i |
		(enclosingNested at: i) simpleName = intermediate simpleName ifTrue:
			[intermediate accessor: (enclosingNested at: i) accessor.
			 enclosingNested at: i put: intermediate]].

	enclosingBuilder:: ClassDeclarationBuilder fromIntermediate: enclosingIR.
	enclosingIR builder: enclosingBuilder.
	enclosingBuilder instanceSide. (* Populate for incremental scope building. *)
	^enclosingBuilder
)
public instanceSide ^<MixinBuilder> = (
	| ir builder |
	ir:: intermediate instanceSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder fromIntermediate: ir.
		 ir builder: builder].
	^builder
)
public name = (
	^intermediate simpleName
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: intermediate.
	^sb asString
)
ensureIRForToplevel = (
(* The enclosing IR is computed lazily. Proior to installation, we need to be sure it exists all the way to the top level *)
	| outermost |
	outermost:: self.
	[nil = outermost enclosingClass] whileFalse:
		[outermost:: outermost enclosingClass].
)
public install ^<ClassDeclarationMirror> = (
	| installer outermost |
	installer:: AtomicInstaller new.
    ensureIRForToplevel.
	outermost:: intermediate.
	[nil = outermost enclosingClass] whileFalse:
		[outermost:: outermost enclosingClass declaration].
	installer install: {outermost}.
	nil = intermediate existingMixin ifTrue: [halt].
	^ClassDeclarationMirror reflecting: intermediate existingMixin
)
private to: sb writeClassDeclaration: declIR = (
	sb add: declIR headerSource.
	sb writeln: ' ('.
    declIR instanceSide lazySlots do:
		[:lazySlot | sb writeln: lazySlot source].
	declIR instanceSide nestedClasses do:
		[:nestedIR | to: sb writeClassDeclaration: nestedIR].
	declIR instanceSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ') : ('.
	declIR classSide methods do:
		[:method | sb writeln: method source].
	sb writeln: ')'.
)
) : (
public fromSource: source <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Category'' ', source
)
public fromUnitSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> builder |
	ir:: compiler compileClassSource: source within: nil.
	builder:: self fromIntermediate: ir.
	ir builder: builder.
	^builder
)
)
private class ClassDeclarationMirror reflecting: mxn = (
	|
	mixin <InstanceMixin> = mxn.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassDeclarationMirror
)
public accessModifier ^<Symbol> = (
	^mixin _accessModifier
)
public applyToObject ^<ClassMirror> = (
	nil = mixin _enclosingMixin ifFalse: [^notTopLevel].
	^ClassMirror reflecting: (mixin apply: Object withName: mixin _name enclosingObject: nil)
)
public asBuilder ^<ClassDeclarationBuilder> = (
	| ec ir builder |
	(* nil = mixin _enclosingMixin ifFalse: [unimplemented]. *)
	ec:: nil. (* Intermediates for enclosing class (if any) computed lazily. *)
	ir:: buildIntermediateFor: mixin within: ec.
	builder:: ClassDeclarationBuilder fromIntermediate: ir.
	ir builder: builder.
	^builder
)
public classSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin _classMixin
)
public definingMixin ^<MixinMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public enclosingClass ^<ClassDeclarationMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: em
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public header ^<ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: mixin
)
public instanceSide ^<MixinMirror> = (
	^MixinMirror reflecting: mixin
)
public isKindOfClassDeclarationMirror ^<Boolean> = (
	^true
)
public name = (
	^mixin _name
)
public primaryFactorySelector ^ <Symbol> = (
 ^mixin _primaryFactorySelector
)
public printString = (
	^'ClassDeclarationMirror:',simpleName.
)
public simpleName = (
	(* halt. TestEnvironment classAccessorName *)
	^mixin _name
)
public source ^<String> = (
	| sb = StringBuilder new. |
	to: sb writeClassDeclaration: mixin.
	^sb asString
)
private to: sb writeClassDeclaration: instanceMixin = (
	sb add: instanceMixin _headerSource.
	sb writeln: ' ('.
    instanceSide lazySlots do:
		[:lazySlot | sb writeln: lazySlot source].
	instanceMixin _nestedMixins do:
		[:nestedMixin | to: sb writeClassDeclaration: nestedMixin].
	instanceMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ') : ('.
	instanceMixin _classMixin _methods do:
		[:method | method isSynthetic ifFalse:
			[sb writeln: method source]].
	sb writeln: ')'.
)
) : (
)
private class ClassHeaderBuilder fromIntermediate: ir = (|
private intermediate <IntermediateClassDeclaration> = ir.
|) (
private checkForHeaderConflicts: newIntermediate <IntermediateClassDeclaration> = (
	newIntermediate instanceSide slots do:
		[:slot <IntermediateSlotDeclaration> |
		intermediate instanceSide
			checkNameConflictsForSlot: slot name
			mutable: slot isMutable].

	intermediate classSide checkNameConflictsForFactory: newIntermediate factoryName.
)
public classComment ^<String> = (
	(* :questionable: *)
	nil = source ifTrue: [^nil].
	^(parsing Parser for: source) advanceToken parseClassHeader classComment value
)
public name = (
	^intermediate simpleName
)
public name: newName <String> = (
	| token newClassSource newIR |

	intermediate builder enclosingClass. (* For side effect. *)

	(* check for name conflict with sibling members *)
	intermediate isTopLevel ifFalse:
		[ | existing |
		existing:: intermediate enclosingClass nestedClasses
			detect: [:nested | nested simpleName = newName]
			ifNone: [nil].
		(nil = existing or: [existing = intermediate builder])
			ifFalse: [^Error signal: 'A sibling already exists with the name ', newName]].

	(* patch header source with the new name *)
	token:: (parsing Parser for: source) advanceToken parseClassHeaderForName.
	newClassSource::
		(intermediate isTopLevel
			(* only top-level classes can specify categories *)
			ifTrue: [ 'Newspeak3 ''Category'' ' ]
			ifFalse: [ ' ' ]),
		(source copyFrom: 1 to: token start - 1) ,
		newName,
		(source copyFrom: token end + 1 to: source size).

	(* compile etc *)
	newIR:: compiler
		compileClassHeader: newClassSource
		within: intermediate enclosingClass.

	intermediate simpleName: newIR simpleName.
	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate comment: newIR comment.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
public preamble ^<Symbol> = (
	(* :questionable: *)
	| headerAst |
	nil = source ifTrue: [^nil].
	headerAst:: (parsing Parser for: source) advanceToken parseClassHeader.
	^source copyFrom: headerAst start to: headerAst superConstructorCall end
)
public source ^<String> = (
	^intermediate headerSource
)
public source: newHeader <String> = (
	| prefix newIR |

	(* only top-level classes can specify categories *)
	prefix:: intermediate isTopLevel
		ifTrue: [ 'Newspeak3 ''Category'' ' ]
		ifFalse: [ '' ].

	intermediate builder enclosingClass. (* For side effect. *)
	newIR:: compiler
		compileClassHeader: (prefix, newHeader)
		within: intermediate enclosingClass.

	checkForHeaderConflicts: newIR.
	assert: [intermediate simpleName = newIR simpleName] message: ''.

	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate comment: newIR comment.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
) : (
)
private class ClassHeaderMirror reflecting: mxn = (
	|
	mixin <InstanceMixin> = mxn.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassHeaderMirror
)
public classComment ^<String> = (
	(* :questionable: *)
	nil = source ifTrue: [^nil].
	^(parsing Parser for: source) advanceToken parseClassHeader classComment value
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfClassHeaderMirror ^<Boolean> = (
	^true
)
public name = (
	^mixin _name
)
public preamble ^<Symbol> = (
	(* :questionable: *)
	| headerAst |
	nil = source ifTrue: [^nil].
	headerAst:: (parsing Parser for: source) advanceToken parseClassHeader.
	^source copyFrom: headerAst start to: headerAst superConstructorCall end
)
public primaryFactorySelector ^ <Symbol> = (
  ^mixin _primaryFactorySelector
)
public selectors ^ <List[Symbol]> = (
  | result <List[Symbol]> = List new. |
  instanceInitializer literals do: [:s |
	 s isKindOfString ifTrue: [result add: (s copyFrom: (s lastIndexOf: '`') + 1 to: s size)]
	].
  ^result
)
public source ^<String> = (
	^mixin _headerSource
)
instanceInitializer ^ <_Method> = (
(* get the mixin's _methods and find the instance initializer *)
  | methods = mixin _methods. |
  1 to: methods size do: [:i <Integer> |
    (isSubinitializerSelector: (methods at: i) selector) ifTrue: [^methods at: i].
	].
  shouldNotHappen.
)
public metadata ^ <Map[String, String]> = (
  ^parseMetadata metadata
)
leftHandSide ^ <String> = (
  | scanner = parsing Scanner for: source.|
  (* get past class keyword & class name *)
  scanner advanceToken; advanceToken; advanceToken.
  [scanner tokenValue = '='] whileFalse: [scanner advanceToken].
  
  ^source copyFrom: 1 to: scanner tokenEnd - 1
)
parseMetadata ^ <MetadataParser> = (
    |
    src <String> = leftHandSide. 
    metadataParser <MetadataParser> = metadataParsing MetadataParser onSource: src.
    |
    metadataParser gatherMetadataBackwards.
    ^metadataParser
)
) : (
)
public class ClassMirror reflecting: behavior = (|
public reflectee <Behavior> = behavior.
|(isBehavior: behavior) ifFalse: [^Error new signal].
reflectees at: self put: behavior) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfClassMirror
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: (enclosingObjectOf: reflectee)
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) hash bitXor: class hash
)
public isKindOfClassMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^Metaclass = (classOf: reflectee)
)
public methods ^<Collection[MethodMirror]> = (
	| cls <Behavior> results <Collection[MethodMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(methodsOf: cls) do:
			[:method <Method> |
			method isSynthetic ifFalse:
				[results add: (MethodMirror reflecting: method)]].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results.
)
public mixin ^<MixinMirror> = (
	^MixinMirror reflecting: (mixinOf: reflectee)
)
public nestedClasses = (
	| cls <Behavior> results <Collection[ClassDeclarationMirror]> |
	cls:: reflectee.
	results:: List new.
	[nil = cls] whileFalse:
		[(mixinOf: cls) _nestedMixins do:
			[:nestedMixin <InstanceMixin> |
			results add: (ClassDeclarationMirror reflecting: nestedMixin)].
		cls:: superclassOf: cls].
	^MirrorGroup wrapping: results
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| cls <Behavior> classes result <Collection[SlotDeclarationMirror]> |
	cls:: reflectee.
	classes:: List new.
	result:: List new.
	[nil = cls] whileFalse:
		[classes add: cls.
		cls:: superclassOf: cls].
	classes size to: 1 by: -1 do:
		[:index |
		cls:: classes at: index.
		(mixinOf: cls) _slots do:
			[:slotDescriptor |
			| name isMutable accessModifier |
			name:: slotDescriptor at: 1.
			isMutable:: slotDescriptor at: 2.
			accessModifier:: slotDescriptor at: 3.
			(name indexOf: '`') = 0 ifTrue:
				[(* Not synthetic. *)
				result add: (SlotDeclarationMirror
					name: name
					isMutable: isMutable
					accessModifier: accessModifier
					mixin: self mixin)]]].
	^MirrorGroup wrapping: result
)
public superclass ^<ClassMirror> = (
	| s = superclassOf: reflectee. |
	nil = s ifTrue: [^nil].
	^ClassMirror reflecting: s
)
public allInstances ^ <Array> = (
	^class allInstancesOf: reflectee
)
public lazySlots ^<Collection[MethodMirror]> = (
	| cls <Behavior> results <Collection[MethodMirror]> |
	^mixin lazySlots
)
) : (
public allInstancesOf: b <Behavior> ^ <Array> = (
	(* :literalmessage: primitive: 96 *)
	halt.
)
)
private class LocalSlotMirror name: n value: v = (
|
public name <Symbol> = n.
public value <ObjectMirror> = v.
|
) (
) : (
)
private class MethodBuilder reflecting: ir in: builder = (|
private intermediate = ir.
public definingMixin = builder.
|) (
public accessModifier = (
	^intermediate accessModifier
)
public name = (
	^intermediate selector
)
public source ^<String> = (
	^intermediate source
)
) : (
)
private class MethodMirror reflecting: m = (|
	method <Method> = m.
|reflectees at: self put: m) (
public = other ^<Boolean> = (
	(is: method identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMethodMirror
)
public accessModifier ^<Symbol> = (
	^method accessModifier
)
public definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: method mixin
)
public hash ^<Integer> = (
	^(identityHashOf: method) hash bitXor: class hash
)
public isKindOfMethodMirror ^<Boolean> = (
	^true
)
public name = (
	^method selector
)
public source ^<String> = (
	(* :todo: Should this be async? *)
	^method source
)
public metadata ^ <Map[String, String]> = (
  ^parseMetadata metadata
)
parseMetadata ^ <MetadataParser> = (
    |
    src <String> = source copyFrom: 1 to: (source indexOf: '=' startingAt: 1) - 1. 
    metadataParser <MetadataParser> = metadataParsing MetadataParser onSource: src.
    |
    metadataParser gatherMetadataBackwards.
    ^metadataParser
)
sizeOf: bytecode = (
	bytecode <= 223 ifTrue: [^1].
	bytecode <= 248 ifTrue: [^2].
	^3
)
commonSend: offset = (
  ^{#+. #-. #<. #>. #<=. #>=. #=. #~=. #*. #/. #\\. #@. #bitShift:. #//. #bitAnd:. #bitOr:. #at:. #at:put:. #size. #next. #nextPut:. #atEnd. #==. #class. #blockCopy:. #value. #value:. #do:. #new. #new:. #x. #y.} at: offset.
)
selectorsFromBytecode ^ <List[Symbol]> = (
  (* Search the bytecode for selectors implied by common send instructions. *)
  |
  pc ::= 1.
  bytecode = method bytecode.
  result <List[Symbol]> = List new.
  |
  [ pc > bytecode size ] whileFalse: [
    | instruction = bytecode at: pc. |
    (instruction > 79 and: [instruction <= 111]) ifTrue: [
      result add: (commonSend: instruction - 79).
    ].
    pc:: pc + (sizeOf: instruction).
  ].
  ^result
)
public selectors ^ <List[Symbol]> = (
 | result <List[Symbol]> = selectorsFromBytecode. |
  method literals do: [:s |
        s isKindOfString ifTrue: [result add: s]
       ].
  ^result
)
) : (
)
private class MirrorGroup wrapping: collection = Collection (|
	protected mirrors <Collection[E extends Mirror]> = collection.
|) (
public do: action <[:E]> = (
	mirrors do: action
)
public findMirrorNamed: name <String> ^<E> = (
	(* :questionable: *)
	mirrors do: [:mirror | mirror name = name ifTrue: [^mirror]].
	^nil
)
public includesMirrorNamed: name <String> ^<Boolean> = (
	(* :questionable: *)
	mirrors do: [:mirror | mirror name = name ifTrue: [^true]].
	^false
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public size ^<Integer> = (
	^mirrors size
)
) : (
)
private class MixinBuilder fromIntermediate: ir = (|
private intermediate <IntermediateMixin> = ir.
private methodsX
private nestedClassesX
private slotsX
private lazySlotsX
|) (
public declaration ^<ClassDeclarationBuilder> = (
	^intermediate declaration builder
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public methods = (
	nil = methodsX ifTrue:
		[methodsX:: MutableMethodGroup fromIntermediate: intermediate].
	^methodsX
)
public nestedClasses = (
	nil = nestedClassesX ifTrue:
		[nestedClassesX:: MutableNestedClassGroup fromIntermediate: intermediate].
	^nestedClassesX
)
public slots = (
	nil = slotsX ifTrue:
		[slotsX:: MutableSlotGroup fromIntermediate: intermediate].
	^slotsX
)
public lazySlots = (
	nil = lazySlotsX ifTrue:
		[lazySlotsX:: LazyMutableSlotGroup fromIntermediate: intermediate].
	^lazySlotsX
)
) : (
)
private class MixinMirror reflecting: mxn = (
	|
	mixin <AbstractMixin> = mxn.
	|
	reflectees at: self put: mxn.
) (
public = other ^<Boolean> = (
	(mixin = (reflectees at: other)) ifFalse: [^false].
	^other isKindOfMixinMirror
)
public asBuilder ^<MixinBuilder> = (
	^isMeta
		ifTrue: [declaration asBuilder classSide]
		ifFalse: [declaration asBuilder instanceSide]
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting:
		(mixin isMeta ifTrue: [mixin _instanceMixin] ifFalse: [mixin])
)
public enclosingMixin ^<ClassDeclarationMirror> = (
	| em = mixin _enclosingMixin. |
	nil = em ifTrue: [^nil].
	^MixinMirror reflecting: em
)
public hash ^<Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^mixin isMeta
)
public name ^<String> = (
	^mixin _name
)
public nestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| results <Collection[ClassDeclarationMirror]> |
	results:: List new.
	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> |
		results add: (ClassDeclarationMirror reflecting: nestedMixin)].
	^MirrorGroup wrapping: results
)
public primaryFactorySelector ^ <Symbol> = (
  ^isMeta ifFalse: [mixin _primaryFactorySelector] ifTrue: [mixin _instanceMixin _primaryFactorySelector].
)
public slots ^<Collection[SlotDeclarationMirror]> = (
	| results = List new. |
	mixin _slots do: [:slotDescriptor |
		| slotName isMutable accessModifier |
		slotName:: slotDescriptor at: 1.
		isMutable:: slotDescriptor at: 2.
		accessModifier:: slotDescriptor at: 3.
		0 = (slotName indexOf: '`') ifTrue: (* not synthetic *)
			[results add: (SlotDeclarationMirror
				name: slotName
				isMutable: isMutable
				accessModifier: accessModifier
				mixin: self)]].
	^MirrorGroup wrapping: results
)
public methods ^<MirrorGroup[MethodMirror]> = (
	| results = List new. |
	mixin _methods do:
		[:method |
		method isSynthetic ifFalse:
			[results add: (MethodMirror reflecting: method)]].
	^MirrorGroup wrapping: results
)
public lazySlots = (
	| results = List new. |
    (* Go thru raw slots *)
	mixin _slots do:
		[:slotDescriptor | | slotName = slotDescriptor at: 1.  i = slotName indexOf: '`cache`slot'. | 
          (* select slots whose name ends with `cache`slot *)
          (i ~= 0 and: [slotName size - 10 = i]) ifTrue: [
             (* and create a mirror for them *)
			  results add: (LazySlotMirror reflecting: (slotName copyFrom: 1 to: i -1) in: self)
              ]
       ].
	^MirrorGroup wrapping: results
)
public applications ^<Collection[ClassMirror]> = (
(* Answer a collection of all classes that have the reflectee as their direct mixin. Note this does not include classes whose superclasses have the reflectee as their mixin. The order of classes is undefined. The result may include classes that are otherwise unreachable because garbage collection has not completed since the last reference was erased. *)
	| result = List new. applications <WeakArray> |
	applications:: (isMeta ifTrue: [mixin _instanceMixin] ifFalse: [mixin]) _applications.
	nil = applications ifTrue: [^result].
	applications do:
		[:application | nil = application ifFalse:
			[result add:
				(ClassMirror reflecting:
					(isMeta ifTrue: [classOf: application] ifFalse: [application]))]].
	^result
)
) : (
)
private class MutableMethodGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> = (
	|
	imethod <IntermediateMethod>
	|
	imethod:: compiler
		compileMethodSource: source
		within: intermediate builder.

	intermediate checkNameConflictsForMethod: imethod selector.

	intermediate methods removeAllSuchThat:
		[:ea | ea selector = imethod selector].
	intermediate methods add: imethod.

	^MethodBuilder reflecting: imethod in: intermediate builder
)
public do: action = (
	intermediate methods do:
		[:intermediateMethod |
		action value: (MethodBuilder
			reflecting: intermediateMethod
			in: intermediate builder)].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public removeMirrorNamed: name <Symbol> = (
	intermediate methods removeAllSuchThat:
		[:imethod | imethod isSynthetic not and: [imethod selector = name]].
)
) : (
)
private class MutableNestedClassGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	| idecl <IntermediateClassDeclaration> builder |

	idecl:: compiler
		compileClassSource: source
		within: intermediate.

	intermediate checkNameConflictsForNestedClass: idecl simpleName.

	intermediate nestedClasses removeAllSuchThat:
		[:nestedIR | nestedIR simpleName = idecl simpleName].
	intermediate nestedClasses add: idecl.

	builder:: ClassDeclarationBuilder fromIntermediate: idecl.
	idecl builder: builder.
	^builder
)
public do: action = (
	intermediate nestedClasses do:
		[:intermediateClassDeclaration |
		| builder |
		builder:: intermediateClassDeclaration builder.
		nil = builder ifTrue:
			[builder:: ClassDeclarationBuilder fromIntermediate: intermediateClassDeclaration.
			intermediateClassDeclaration builder: builder.

			(* :bogus: also find existingMixin *)
			].
		action value: builder].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public removeMirrorNamed: name <Symbol> = (
	| nestedIntermediate |
	intermediate nestedClasses removeAllSuchThat:
		[:inested | inested simpleName = name].
)
) : (
)
private class MutableSlotGroup fromIntermediate: ir = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
public do: action = (
	intermediate slots do:
		[:intermediateSlot |
		action value: (SlotDeclarationMirror
			name: intermediateSlot name
			isMutable: intermediateSlot isMutable
			accessModifier: intermediateSlot accessModifier
			mixin: intermediate builder)].
)
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
) : (
)
public class ObjectMirror reflecting: object = (|
public reflectee = object.
|reflectees at: self put: reflectee) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfObjectMirror
)
private compileExpression: expression <String> with: rawScope <Map[Symbol, Object]> ^<Method> = (
	| receiverClass mixinMirror imethod result |
	receiverClass:: classOf: reflectee.
	mixinMirror:: (ClassMirror reflecting: receiverClass) mixin.
	imethod:: compiler
		compileExpressionSource: expression
		debugMapper: nil
		withScope: rawScope
		inMixin: mixinMirror.

	imethod methodMixin: (mixinOf: receiverClass).
	imethod source: expression.
	imethod debugInfo source: expression.
	^imethod compiledMethod metadata: imethod debugInfo
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^(evaluateSuspended: expression) resume
)
public evaluate: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (
	^(evaluateSuspended: expression with: scope) resume
)
public evaluateSuspended: expression <String> ^<ThreadMirror> = (
	^evaluateSuspended: expression with: Map new
)
public evaluateSuspended: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^ <ThreadMirror> = (
	|
	rawScope <Map[Symbol, Object]>
	expressionMethod <Method>
	thread <Thread>
	simulator <Simulator>
	|
	rawScope:: Map new.
	scope keysAndValuesDo: [:key :value | rawScope at: key put: (reflectees at: value)].
	expressionMethod:: compileExpression: expression with: rawScope.

	simulator:: Simulator new.
	simulator activate: expressionMethod receiver: reflectee arguments: {nil. rawScope}.

	thread:: Thread new.
	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public getClass ^<ClassMirror> = (
	^ClassMirror reflecting: (classOf: reflectee)
)
public getSlot: name = (
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	raw:: slotOf: reflectee at: index.
	^ObjectMirror reflecting: raw
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
private indexOfSlotNamed: name in: startCls = (
	| cls slots |
	cls:: startCls.
	[nil = cls] whileFalse:
		[slots:: (mixinOf: cls) _slots.
		 1 to: slots size do:
			[:index | ((slots at: index) at: 1) = name ifTrue:
				[^(formatOf: cls) - slots size + index]].
		 cls:: (superclassOf: cls)].
	^-1
)
public isKindOfObjectMirror ^<Boolean> = (
	^true
)
public setSlot: name to: value = (
	| index raw |
	index:: indexOfSlotNamed: name in: (classOf: reflectee).
	slotOf: reflectee at: index put: value.
)
public perform: selector <String> with: args <Array[Object]> ifFail: fblk <[:Exception]> ^ <ObjectMirror> = (
	| msg <Message> = Message selector: selector arguments: args.  |
	^[msg sendTo: reflectee] on: Error do: fblk
)
public performPublic: selector <String> with: args <Array[Object]> ^ <ObjectMirror> = (
	| msg <Message> = Message selector: selector arguments: args.  |
	^msg sendTo: reflectee
)
selectMethodToSuspend: selector <String> ^ <Method>  = (
  | 
  klass <ClassMirror> = getClass. 
  m <MethodMirror> = klass methods 
       detect: [:m <MethodMirror> | selector = m name]
       ifNone: [(klass lazySlots detect: [:ls <LazySlotMirror> | selector = ls name]) mainMethod].
  |
  ^reflectees at: m
)
public sendSuspended: selector <String> with: args <List[Object]> ^ <ThreadMirror> = (
	|
	selectedMethod <Method> = selectMethodToSuspend: selector.
	thread <Thread> = Thread new.
	simulator <Simulator> = Simulator new.
	|

	simulator activate: selectedMethod receiver: reflectee arguments: args.

	thread state: #suspended.
	thread suspendedActivation: simulator activation.

	^ThreadMirror reflecting: thread
)
public getLazySlot: name = (
	| 
    rawName = intermediatesX IntermediateLazySlot slotNameForLazySlotNamed: name.
	index = indexOfSlotNamed: rawName in: (classOf: reflectee).
	raw =  slotOf: reflectee at: index.
    |
	^ObjectMirror reflecting: raw
)
) : (
)
private class Simulator = (|
public activation
|) (
aboutToReturn: result through: firstUnwindActivation = (
	| method |
	method:: behavior: Activation methodAt: #aboutToReturn:through:.
	activate: method receiver: activation arguments: {result. firstUnwindActivation}.
)
public activate: newMethod receiver: newReceiver arguments: arguments = (
	| primitive = newMethod primitive. result newActivation |

	0 = primitive ifFalse:
		[(* Simulation guard *)
		112 = primitive ifTrue: ['simulation guard' out. halt. ].

		(* Current activation *)
		133 = primitive ifTrue: [activation push: activation. ^self].

		(* Closure activation *)
		90 = primitive ifTrue:
			[newReceiver numArgs = 0 ifTrue:
				[^activateClosure: newReceiver arguments: arguments]].
		91 = primitive ifTrue:
			[newReceiver numArgs = 1 ifTrue:
				[^activateClosure: newReceiver arguments: arguments]].
		92 = primitive ifTrue:
			[newReceiver numArgs = 2 ifTrue:
				[^activateClosure: newReceiver arguments: arguments]].
		93 = primitive ifTrue:
			[newReceiver numArgs = 3 ifTrue:
				[^activateClosure: newReceiver arguments: arguments]].
		94 = primitive ifTrue: [
			| closureArgs = arguments at: 1. |
			(Array = (classOf: closureArgs)) ifTrue:
				[closureArgs size = newReceiver numArgs ifTrue:
					[^activateClosure: newReceiver arguments: closureArgs]]].

		(* Jump *)
		95 = primitive ifTrue: [
			activation:: arguments at: 1.
			^self].

		(* Perform *)
		89 = primitive ifTrue: [
			| object selector performArguments |
			object:: arguments at: 1.
			selector:: arguments at: 2.
			performArguments:: arguments at: 3.
			(* :todo: Where should we fail on arity mismatch? *)
			(String = (classOf: selector)) ifTrue:
				[(Array = (classOf: performArguments)) ifTrue:
					[activation push: object.
					performArguments do: [:arg | activation push: arg].
					^ordinarySend: selector numArgs: performArguments size]]].

		result:: doPrimitive: primitive receiver: newReceiver arguments: arguments.
		arguments = result ifFalse:
			[activation push: result.
			 ^self]].

	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: 1.
	newActivation method: newMethod.
	newActivation closure: nil.
	newActivation receiver: newReceiver.

	newActivation size: newMethod numTemps.
	1 to: arguments size do:
		[:index | newActivation tempAt: index put: (arguments at: index)].

	(* ('sim: ', newActivation printString) out. *)

	activation:: newActivation.
)
public activateClosure: closure arguments: arguments = (
	| newActivation |
	newActivation:: Activation new.
	newActivation sender: activation.
	newActivation bci: (initialBCIOf: closure).
	newActivation method: (definingActivationOf: closure) method.
	newActivation closure: closure.
	newActivation receiver: (definingActivationOf: closure) receiver.
	arguments size = closure numArgs ifFalse: [halt].
	arguments do:
		[:argument | newActivation push: argument].
	1 to: (numCopiedOf: closure) do:
		[:index | newActivation push: (copiedOf: closure at: index)].

	(* ('sim: ', newActivation printString) out. *)
	activation:: newActivation.
)
behavior: behavior hasSelector: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^true]].
	^false
)
public behavior: behavior methodAt: selector = (
	(methodsOf: behavior) do: [:method | method selector = selector ifTrue: [^method]].
	^nil
)
blockReturn: result = (
	localReturn: result
)
cannotReturn: result = (
	| method |
	method:: behavior: Activation methodAt: #cannotReturn:.
	activate: method receiver: activation arguments: {result}.
)
commonArithmeticSend: offset = (
	0 = offset ifTrue: [^ordinarySend: #+ numArgs: 1].
	1 = offset ifTrue: [^ordinarySend: #- numArgs: 1].
	2 = offset ifTrue: [^ordinarySend: #< numArgs: 1].
	3 = offset ifTrue: [^ordinarySend: #> numArgs: 1].
	4 = offset ifTrue: [^ordinarySend: #<= numArgs: 1].
	5 = offset ifTrue: [^ordinarySend: #>= numArgs: 1].
	6 = offset ifTrue: [^ordinarySend: #= numArgs: 1].
	7 = offset ifTrue: [^ordinarySend: #~= numArgs: 1].
	8 = offset ifTrue: [^ordinarySend: #* numArgs: 1].
	9 = offset ifTrue: [^ordinarySend: #/ numArgs: 1].
	10 = offset ifTrue: [^ordinarySend: #\\ numArgs: 1].
	11 = offset ifTrue: [^ordinarySend: #@ numArgs: 1].
	12 = offset ifTrue: [^ordinarySend: #bitShift: numArgs: 1].
	13 = offset ifTrue: [^ordinarySend: #// numArgs: 1].
	14 = offset ifTrue: [^ordinarySend: #bitAnd: numArgs: 1].
	15 = offset ifTrue: [^ordinarySend: #bitOr: numArgs: 1].
)
commonSend: offset = (
	0 = offset ifTrue: [^ordinarySend: #at: numArgs: 1].
	1 = offset ifTrue: [^ordinarySend: #at:put: numArgs: 2].
	2 = offset ifTrue: [^ordinarySend: #size numArgs: 0].
	3 = offset ifTrue: [^ordinarySend: #next numArgs: 0].
	4 = offset ifTrue: [^ordinarySend: #nextPut: numArgs: 1].
	5 = offset ifTrue: [^ordinarySend: #atEnd numArgs: 0].
	6 = offset ifTrue: [^ordinarySend: #== numArgs: 1].
	7 = offset ifTrue: [^ordinarySend: #class numArgs: 0].
	8 = offset ifTrue: [^ordinarySend: #blockCopy: numArgs: 1].
	9 = offset ifTrue: [^ordinarySend: #value numArgs: 0].
	10 = offset ifTrue: [^ordinarySend: #value: numArgs: 1].
	11 = offset ifTrue: [^ordinarySend: #do: numArgs: 1].
	12 = offset ifTrue: [^ordinarySend: #new numArgs: 0].
	13 = offset ifTrue: [^ordinarySend: #new: numArgs: 1].
	14 = offset ifTrue: [^ordinarySend: #x numArgs: 0].
	15 = offset ifTrue: [^ordinarySend: #y numArgs: 0].
)
private doPrimitive: index <Integer> receiver: receiver <Object> arguments: arguments <Array> = (
	(* :literalmessage: primitive: 141 *)
	'doPrimitive failed' out.
	index out.
	receiver out.
	arguments size out.
	halt.
)
dup = (
	activation push: activation top.
)
public findApplicationOf: mixin startingAt: startingBehavior = (
	| behavior ::= startingBehavior. |
	[nil = behavior] whileFalse:
		[mixin = (mixinOf: behavior) ifTrue: [^behavior].
		 behavior:: (superclassOf: behavior)].
	halt.
)
implicitReceiverSend: selectorOffset numArgs: numArgs = (
	| selector arguments candidateReceiver candidateMixin candidateMixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	candidateReceiver:: activation receiver.
	candidateMixin:: activation method mixin.
	[candidateMixinApplication::
		findApplicationOf: candidateMixin
		startingAt: (classOf: candidateReceiver).
	(behavior: candidateMixinApplication hasSelector: selector) ifTrue:
		[^sendLexical: selector to: candidateReceiver arguments: arguments wrt: candidateMixin].
	candidateMixin:: candidateMixin _enclosingMixin.
	nil = candidateMixin ifTrue:
		[^sendProtected: selector to: activation receiver arguments: arguments startingAt: (classOf: activation receiver)].
	candidateReceiver:: enclosingObjectOf: candidateMixinApplication.
	] repeat.
)
interpretNext1Byte: byte extA: extA extB: extB = (
	byte <= 15 ifTrue: [^self unusedBytecode (* squeak: pushReceiverVariable *)].
	byte <= 31 ifTrue: [^self pushLiteralVariable: (byte bitAnd: 15)].
	byte <= 63 ifTrue: [^self pushLiteral: (byte bitAnd: 31)].
	byte <= 71 ifTrue: [^self pushTemporary: (byte bitAnd: 7)].
	byte <= 75 ifTrue: [^self pushTemporary: (byte bitAnd: 7) + 8].
	byte <= 76 ifTrue: [^self pushReceiver].
	byte <= 77 ifTrue: [^self pushSpecial: extB].
	byte <= 78 ifTrue: [^self pushInteger: 0].
	byte <= 79 ifTrue: [^self pushInteger: 1].
	byte <= 95 ifTrue: [^self commonArithmeticSend: (byte bitAnd: 15)].
	byte <= 111 ifTrue: [^self commonSend: (byte bitAnd: 15)].
	byte <= 127 ifTrue:
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 0].
	byte <= 143 ifTrue:
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 1].
	byte <= 159 ifTrue:
		[^self ordinarySend: (activation method literals at: (byte bitAnd: 15) + 1) numArgs: 2].
	byte <= 175 ifTrue: [^self implicitReceiverSend: (byte bitAnd: 15) numArgs: 0].
	byte <= 183 ifTrue: [^self unusedBytecode (* squeak: popIntoReceiverVariable *)].
	byte <= 191 ifTrue: [^self popIntoTemporary: (byte bitAnd: 7)].
	byte <= 199 ifTrue: [^self jump: (byte bitAnd: 7) + 1].
	byte <= 207 ifTrue: [^self popJumpTrue: (byte bitAnd: 7) + 1].
	byte <= 215 ifTrue: [^self popJumpFalse: (byte bitAnd: 7) + 1].
	byte <= 216 ifTrue: [^self methodReturn: activation receiver].
	byte <= 217 ifTrue: [^self methodReturn: activation pop].
	byte <= 218 ifTrue: [^self blockReturn: activation pop].
	byte <= 219 ifTrue: [^self dup].
	byte <= 220 ifTrue: [^self pop].
	byte <= 221 ifTrue: [^self (* nop *)].
	byte <= 222 ifTrue: [^self break].

	(* 223 *) ^self unusedBytecode
)
interpretNext2Byte: byte1 byte: byte2 extA: extA extB: extB = (
	byte1 <= 224 ifTrue:
		[^self interpretNextInstructionExtA: (extA << 8) + byte2 extB: extB].
	byte1 <= 225 ifTrue:
		[^self interpretNextInstructionExtA: extA extB:
			((extB = 0 and: [byte2 > 127])
				ifTrue: [byte2 - 256]
				ifFalse: [(extB << 8) + byte2])].

	byte1 <= 226 ifTrue: [^self unusedBytecode (* squeak: pushReceiverVariable *)].
	byte1 <= 227 ifTrue: [^self pushLiteralVariable: (extA << 8) + byte2].
	byte1 <= 228 ifTrue: [^self pushLiteral: (extA << 8) + byte2].
	byte1 <= 229 ifTrue: [^self pushInteger: (extB << 8) + byte2].
	byte1 <= 230 ifTrue: [^self pushTemporary: byte2].
	byte1 <= 231 ifTrue:
		[byte2 < 128
			ifTrue: [^self pushNewArray: byte2]
			ifFalse: [^self pushNewArrayWithElements: byte2 - 128]].
	byte1 <= 232 ifTrue: [^self unusedBytecode (* squeak: storeIntoReceiverVariable *)].
	byte1 <= 233 ifTrue: [^self unusedBytecode (* squeak: storeIntoLiteralVariable *)].
	byte1 <= 234 ifTrue: [^self storeIntoTemporary: byte2].
	byte1 <= 235 ifTrue: [^self unusedBytecode (* squeak: popIntoReceiverVariable *)].
	byte1 <= 236 ifTrue: [^self unusedBytecode (* squeak: popIntoLiteralVariable *)].
	byte1 <= 237 ifTrue: [^self popIntoTemporary: byte2].
	byte1 <= 238 ifTrue:
		[^self ordinarySend: (activation method literals at: (extA << 5) + (byte2 >> 3) + 1)
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 239 ifTrue: [^self unusedBytecode (* squeak: staticSuperSend *)].
	byte1 <= 240 ifTrue:
		[^self implicitReceiverSend: (extA << 5) + (byte2 >> 3)
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 241 ifTrue:
		[^self superSend: (extA << 5) + (byte2 >> 3)
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].
	byte1 <= 242 ifTrue: [^self jump: (extB << 8) + byte2].
	byte1 <= 243 ifTrue: [^self popJumpTrue: (extB << 8) + byte2].
	byte1 <= 244 ifTrue: [^self popJumpFalse: (extB << 8) + byte2].
	byte1 <= 245 ifTrue:
		[^self selfSend: (extA << 5) + (byte2 >> 3)
		numArgs: (extB << 3) + (byte2 bitAnd: 7)].

	(* 246, 247, 248 *) ^self unusedBytecode
)
interpretNext3Byte: byte1 byte: byte2 byte: byte3 extA: extA extB: extB ^<Activation> = (
	byte1 <= 249 ifTrue: [^unusedBytecode (* squeak: callPrimitive *)].
	byte1 <= 250 ifTrue: [^self pushRemoteTemp: byte2 inVector: byte3].
	byte1 <= 251 ifTrue: [^self storeIntoRemoteTemp: byte2 inVector: byte3].
	byte1 <= 252 ifTrue: [^self popIntoRemoteTemp: byte2 inVector: byte3].
	byte1 <= 253 ifTrue:
		[^self
			pushClosureNumCopied: ((byte2 >> 3) bitAnd: 7) + ((extA // 16) << 3)
			numArgs: (byte2 bitAnd: 7) + ((extA \\ 16) << 3)
			blockSize: (extB << 8) + byte3].
	byte1 <= 254 ifTrue:
		[^self
			outerSend: (extA << 5) + (byte2 >> 3)
			numArgs: (extB << 3) + (byte2 bitAnd: 7)
			depth: byte3].

	(* 255 *)
	^unusedBytecode
)
public interpretNextInstruction = (
	self interpretNextInstructionExtA: 0 extB: 0
)
interpretNextInstructionExtA: extA extB: extB = (
	| bci bytecode byte byte2 byte3 |
	bci:: activation bci.
	bytecode:: activation method bytecode.
	byte:: bytecode at: bci.
	byte <= 223 ifTrue:
		[activation bci: bci + 1.
		 ^interpretNext1Byte: byte extA: extA extB: extB].

	byte2:: bytecode at: bci + 1.
	byte <= 248 ifTrue:
		[activation bci: bci + 2.
		^interpretNext2Byte: byte byte: byte2 extA: extA extB: extB].

	byte3:: bytecode at: bci + 2.
	activation bci: bci + 3.
	^interpretNext3Byte: byte byte: byte2 byte: byte3 extA: extA extB: extB
)
jump: delta = (
	activation bci: activation bci + delta.
)
localReturn: result = (
	| sender = activation sender. |
	nil = sender ifTrue: [^cannotReturn: result].
	sender isDead ifTrue: [^cannotReturn: result].
	activation terminate.
	sender push: result.
	activation: sender.
)
methodReturn: result = (
	nil = activation closure
		ifTrue: [localReturn: result]
		ifFalse: [nonLocalReturn: result]
)
private newClosureIn: definingActivation initialBCI: initialBCI numArgs: numArgs numCopied: numCopied = (
	(* :literalmessage: primitive: 69 *)
	halt.
)
nonBooleanReceiver: nonBoolean = (
	| method |
	method:: behavior: Activation methodAt: #nonBooleanReceiver:.
	activate: method receiver: activation arguments: {nonBoolean}.
)
nonLocalReturn: result = (
	| closure home unwind sender zap next |
	closure:: activation closure.
	home:: definingActivationOf: closure.
	closure:: home closure.
	[nil = closure] whileFalse:
		[home:: definingActivationOf: closure.
		 closure:: home closure].

	unwind:: activation sender.
	[unwind = home] whileFalse:
		[nil = unwind ifTrue:
			[^cannotReturn: result].
		unwind method primitive = 113 ifTrue:
			[^aboutToReturn: result through: unwind].
		unwind method primitive = 142 ifTrue:
			[^cannotReturn: result].
		unwind:: unwind sender].

	sender:: home sender.
	(nil = sender or: [sender isDead]) ifTrue:
		[^cannotReturn: result].

	(* Mark activations on the dynamic chain up to the return target as dead. Note this follows the behavior of Squeak instead of the blue book, which only zaps A. *)
	zap:: activation.
	[next:: zap sender.
	 zap terminate.
	 zap:: next.
	 zap = sender] whileFalse.

	sender push: result.
	activation: sender.
	(* ('sim: ', activation printString) out. *)
)
ordinarySend: selector numArgs: numArgs = (
	| arguments messageReceiver receiverClass lookupClass targetMethod |
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation pop.
	lookupClass:: receiverClass:: classOf: messageReceiver.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		 nil = targetMethod ifFalse:
			[targetMethod isPublic ifTrue:
				[^activate: targetMethod receiver: messageReceiver arguments: arguments].
			 targetMethod isProtected ifTrue:
				[^sendDnu: selector to: messageReceiver arguments: arguments startingAt: receiverClass]].
		 lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments startingAt: receiverClass
)
outerSend: selectorOffset numArgs: numArgs depth: depth = (
	| selector arguments receiver targetMixin count mixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	receiver:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: receiver).
		receiver:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	^sendLexical: selector to: receiver arguments: arguments wrt: targetMixin.
)
pop = (
	activation pop
)
popIntoRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	vector at: 1 + offset put: activation pop.
)
popIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation pop.
)
popJumpFalse: delta = (
	| top = activation pop. |
	true = top ifTrue: [^self].
	false = top ifTrue:
		[activation bci: activation bci + delta.
		^self].
	^nonBooleanReceiver: top
)
popJumpTrue: delta = (
	| top = activation pop. |
	true = top ifTrue:
		[activation bci: activation bci + delta.
		^self].
	false = top ifTrue: [^self].
	^nonBooleanReceiver: top
)
pushClosureNumCopied: numCopied numArgs: numArgs blockSize: blockSize ^<Activation> = (
	| newClosure |
	newClosure::
		newClosureIn: activation
		initialBCI: activation bci
		numArgs: numArgs
		numCopied: numCopied.

	numCopied to: 1 by: -1 do:
		[:index | copiedOf: newClosure at: index put: activation pop].

	activation push: newClosure.
	activation bci: activation bci + blockSize.
)
pushEnclosingObject: depth = (
	| enclosingObject targetMixin count mixinApplication |
	enclosingObject:: activation receiver.
	targetMixin:: activation method mixin.
	count:: 0.
	[count < depth] whileTrue:
		[count:: count + 1.
		mixinApplication:: findApplicationOf: targetMixin startingAt: (classOf: enclosingObject).
		enclosingObject:: enclosingObjectOf: mixinApplication.
		targetMixin:: targetMixin _enclosingMixin].
	activation push: enclosingObject.
)
pushInteger: value = (
	activation push: value
)
pushLiteral: offset = (
	| literals = activation method literals. |
	literals size + 1 = offset
		ifTrue: [(* Squeak method class association *) activation push: activation method mixin]
		ifFalse: [activation push: (literals at: 1 + offset)].
)
pushLiteralVariable: offset = (
	(* Not used in Newspeak, except by the implementation of eventual sends. *)
	pushMessageLoop.
)
pushNewArray: size ^<Activation> = (
	activation push: (Array new: size).
)
pushNewArrayWithElements: size ^<Activation> = (
	| newArray = Array new: size. |
	size to: 1 by: -1 do: [:index | newArray at: index put: activation pop].
	activation push: newArray.
)
pushReceiver = (
	activation push: activation receiver.
)
pushRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	activation push: (vector at: 1 + offset).
)
pushSpecial: extB = (
	extB < 0 ifTrue: [^pushEnclosingObject: 0 - extB].

	0 = extB ifTrue: [activation push: false. ^self].
	1 = extB ifTrue: [activation push: true. ^self].
	2 = extB ifTrue: [activation push: nil. ^self].

	^unusedBytecode
)
pushTemporary: offset = (
	activation push: (activation tempAt: 1 + offset).
)
selfSend: selectorOffset numArgs: numArgs = (
	| selector arguments |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	^sendLexical: selector to: activation receiver arguments: arguments wrt: activation method mixin
)
sendDnu: selector to: messageReceiver arguments: arguments startingAt: mixinApp = (
	| lookupClass message dnuMethod |
	lookupClass:: mixinApp.
	message:: Message selector: selector arguments: arguments.
	[nil = lookupClass] whileFalse:
		[dnuMethod:: behavior: lookupClass methodAt: #doesNotUnderstand:.
		 nil = dnuMethod ifFalse:
			[^activate: dnuMethod receiver: messageReceiver arguments: {message} ].
		 lookupClass:: superclassOf: lookupClass].
	error: 'Recursive doesNotUnderstand:'
)
sendLexical: selector to: messageReceiver arguments: arguments wrt: mixin = (
	| receiverClass mixinApplication targetMethod |
	receiverClass:: classOf: messageReceiver.
	mixinApplication:: findApplicationOf: mixin startingAt: receiverClass.
	targetMethod:: behavior: mixinApplication methodAt: selector.
	nil = targetMethod ifFalse:
		[targetMethod isPrivate ifTrue:
			[^activate: targetMethod receiver: messageReceiver arguments: arguments]].
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: receiverClass
)
sendProtected: selector to: messageReceiver arguments: arguments startingAt: mixinApp = (
	| lookupClass targetMethod |
	lookupClass:: mixinApp.
	[nil = lookupClass] whileFalse:
		[targetMethod:: behavior: lookupClass methodAt: selector.
		 nil = targetMethod ifFalse:
			[targetMethod isPrivate ifFalse:
				[^activate: targetMethod receiver: messageReceiver arguments: arguments]].
		lookupClass:: superclassOf: lookupClass].
	^sendDnu: selector to: messageReceiver arguments: arguments startingAt: mixinApp
)
storeIntoRemoteTemp: offset inVector: vectorOffset = (
	| vector = activation tempAt: 1 + vectorOffset. |
	vector at: 1 + offset put: activation top.
)
storeIntoTemporary: offset = (
	activation tempAt: 1 + offset put: activation top.
)
superSend: selectorOffset numArgs: numArgs = (
	| selector arguments messageReceiver methodMixinApplication |
	selector:: activation method literals at: selectorOffset + 1.
	arguments:: Array new: numArgs.
	numArgs to: 1 by: -1 do: [:i | arguments at: i put: activation pop].
	messageReceiver:: activation receiver.
	methodMixinApplication:: findApplicationOf: activation method mixin startingAt: (classOf: messageReceiver).
	^sendProtected: selector to: messageReceiver arguments: arguments startingAt: (superclassOf: methodMixinApplication)
)
) : (
public bciBefore: afterBci in: method = (
	(* :todo: Also unwind any extension bytecodes.  *)
	| beforeBci bci bytecode = method bytecode. |
	beforeBci:: bci:: 1.
	[bci < afterBci] whileTrue:
		[beforeBci:: bci.
		 bci:: bci + (sizeOf: (bytecode at: bci))].
	^beforeBci
)
sizeOf: bytecode = (
	bytecode <= 223 ifTrue: [^1].
	bytecode <= 248 ifTrue: [^2].
	^3
)
)
private class SlotDeclarationMirror name: n isMutable: m accessModifier: a mixin: mxn = (|
public name = n.
public isMutable = m.
public accessModifier = a.
public definingMixin = mxn.
|) (
public isKindOfSlotDeclarationMirror ^<Boolean> = (
	^true
)
) : (
)
private class SyntheticMethodMirror reflecting: m name: n source: s = MethodMirror reflecting: m (|
	public name <Symbol> = n.
	public source <String> = s.
|) (
) : (
)
private class Thread = (
	|
	public state ::= #initial.
	public result
	public suspendedActivation
	|
) (
private createSimulationRoot = (
	| root = Activation new. |
	(* bottom sender: nil *) (* Note that the current activation is not attached as the sender of the simulated activation. This prevents a non-local return from crossing the simulation boundry. *)
	root method: simulatorRootMethod. (* Marks the activation as a simulation root. Used to route unhandled exceptions. *)
	root bci: 0. (* Marks the activation as not dead so the final return can succeed. *)
	(* bottom closure: nil *)
	(* bottom receiver: nil *)
	root push: self. (* Known to exception signaling machinery. *)
	^root
)
private findBottom: top <Activation> = (
	| bottom ::= top. |
	[isBottom: bottom] whileFalse: [bottom:: bottom sender].
	^bottom
)
private has: top reachedOrSkipped: goal = (
	| a ::= top. |
	a = goal ifTrue: [^true]. (* reached *)
	[nil = a]
		whileFalse:
			[a = goal ifTrue: [^false]. (* not reached, not skipped *)
			 a:: a sender].
	^true (* skipped *)
)
private has: top reachedOrSkippedHome: goal = (
	| a ::= top. |
	a home = goal ifTrue: [^true]. (* reached *)
	[nil = a]
		whileFalse:
			[a home = goal ifTrue: [^false]. (* not reached, not skipped *)
			 a:: a sender].
	^true (* skipped *)
)
private hasSender: activation = (
	| s ::= suspendedActivation. |
	[nil = s] whileFalse: [s = activation ifTrue: [^true]. s:: s sender].
	^false
)
private isBottom: activation <Activation> ^<Boolean> = (
	nil = activation sender ifTrue: [^true].
	^142 = activation sender method primitive
)
private jumpTo: activation = (
	(* :literalmessage: primitive: 95 *)
	halt.
)
private lookupNewMethod: activation = (
	| simulator oldMethod methodClass newMethod |
	simulator:: Simulator new.
	oldMethod:: activation method.
	methodClass:: simulator findApplicationOf: oldMethod mixin startingAt: (classOf: activation receiver).
	newMethod:: simulator behavior: methodClass methodAt: oldMethod selector.
	nil = newMethod ifTrue: [^oldMethod].
	^newMethod
)
private prepareToResumeWithRoot: simulationRoot <Activation> = (
	| top bottom <Activation> |
	top:: suspendedActivation.
	(findBottom: top) sender: simulationRoot.
	state = #broken ifTrue: [top push: result]. (* Result of #signal *)
	state: #running.
	suspendedActivation: nil.
	^top
)
public restart: activation withLookup: doLookup = (
	| closure newMethod |
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].
	doLookup ifTrue:
		[nil = activation closure ifFalse:
			[^Error signal: 'Cannot lookup closure activations']].
	unwindTo: activation.
	newMethod:: doLookup
		ifTrue: [lookupNewMethod: activation]
		ifFalse: [activation method].
	restart: activation withMethod: newMethod.
	state: #suspended.
)
private restart: activation withMethod: newMethod = (
	| closure |
	closure:: activation closure.
	activation method: newMethod.
	nil = closure
		ifTrue:
			[activation bci: 1.
			 activation size: newMethod numArgs.
			 activation size: newMethod numTemps]
		ifFalse:
			[activation bci: (initialBCIOf: closure).
			 activation size: closure numArgs.
			 1 to: (numCopiedOf: closure) do:
				[:index | activation push: (copiedOf: closure at: index)]].
)
public resume = (
	(* The state check is in a separate method because we don't want a method marked as a simulation root to be on the stack when the exception is signaled. *)
	nil = suspendedActivation ifTrue:
		[^Error signal: 'Nothing to resume'].
	^resumeImpl
)
private resumeImpl = (
	(* :literalmessage: primitive: 142 *)
	| threadAtTemp1 jumpResult |
	threadAtTemp1:: self. (* Known to exception signaling machinery. *)
	jumpResult:: jumpTo: (prepareToResumeWithRoot: currentActivation).
	state = #broken ifTrue:
		[result: jumpResult.
		 ^self].
	state: #fulfilled.
	result: jumpResult.
)
public resumeSlowly = (
	stepUntil: [:top | false].
)
public return: returnValue from: activation = (
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].

	(isBottom: activation) ifTrue:
		[unwindTo: activation.
		 suspendedActivation terminate.
		 suspendedActivation:: nil.
		 result:: returnValue.
		 state:: #fulfilled.
		 ^self].

	unwindTo: activation sender.
	suspendedActivation push: returnValue.
	state: #running.
)
private simulatorRoot = (
	(* :literalmessage: primitive: 142 *)
	halt.
)
private simulatorRootMethod = (
	| methods = methodsOf: self class. |
	1 to: methods size do:
		[:index | | method = methods at: index. |
		method selector = #simulatorRoot ifTrue: [^method]].
	halt.
)
public stepInto = (
	nil = suspendedActivation ifTrue:
		[^Error signal: 'Nothing to resume'].
	stepUntil: [:top | true].
)
public stepInto: activation = (
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].
	stepUntil: [:top | true].
)
public stepOut: activation = (
	| goal = activation sender. |
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].
	(isBottom: activation) ifTrue:
		[^resume].
	stepUntil: [:top | has: top reachedOrSkipped: goal].
)
public stepOver: activation = (
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].
	stepUntil: [:top | has: top reachedOrSkipped: activation].
)
public stepThrough: activation = (
	| goal = activation home. |
	(hasSender: activation) ifFalse:
		[^Error signal: 'Activation is not in thread'].
	stepUntil: [:top | has: top reachedOrSkippedHome: goal].
)
private stepUntil: predicate <[:Activation | Boolean]> = (
	| root simulator = Simulator new. |
	root:: createSimulationRoot.
	simulator activation: (prepareToResumeWithRoot: root).
	root = simulator activation ifTrue: [halt].
	[simulator interpretNextInstruction.
	 root = simulator activation or: [predicate value: simulator activation]] whileFalse.
	root = simulator activation ifFalse:
		[state: #suspended.
		 suspendedActivation: simulator activation.
		 ^self].
	state = #broken ifTrue:
		[result: simulator activation pop.
		 ^self].
	state: #fulfilled.
	result: simulator activation pop.
)
public terminate = (
	nil = suspendedActivation ifTrue:
		[^Error signal: 'Nothing to terminate'].
	unwindTo: (findBottom: suspendedActivation) sender.
	suspendedActivation: nil.
	state: #terminated.
	result: nil.
)
private unwindTo: activation = (
	| unwind sender |
	unwind:: suspendedActivation.
	[unwind = activation] whileFalse:
		[unwind isUnwindContext ifTrue:
			[^Error signal: 'Unwind-protect unimplemented'].
		 unwind:: unwind sender].

	unwind:: suspendedActivation.
	[unwind = activation] whileFalse:
		[sender:: unwind sender.
		 unwind terminate.
		 unwind:: sender].
	suspendedActivation:: activation.
)
) : (
)
private class ThreadMirror reflecting: t = (
  | protected thread = t. |
  reflectees at: self put: thread.
) (
protected reflectee = (^thread)
public = other ^<Boolean> = (
	(is: reflectee identicalTo: (reflectees at: other)) ifFalse: [^false].
	^other isKindOfThreadMirror
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) bitXor: class hash
)
public isBroken ^<Boolean> = (
	^thread state = #broken
)
public isFulfilled ^<Boolean> = (
	^thread state = #fulfilled
)
public isKindOfThreadMirror ^ <Boolean> = (
	^true
)
public isRunning ^<Boolean> = (
	^thread state = #running
)
public isSuspended ^<Boolean> = (
	^thread state = #suspended
)
public isTerminated ^<Boolean> = (
	^thread state = #terminated
)
public result ^<ObjectMirror | nil> = (
	thread state = #fulfilled ifTrue: [^ObjectMirror reflecting: thread result].
	thread state = #broken ifTrue: [^ObjectMirror reflecting: thread result].
	^nil
)
public resume ^<ThreadMirror> = (
	thread resume.
)
public resumeSlowly ^<ThreadMirror> = (
	thread resumeSlowly.
)
public stepInto ^<ThreadMirror> = (
	thread stepInto.
)
public suspendedActivation ^<ActivationMirror | nil> = (
	nil = thread suspendedActivation ifTrue: [^nil].
	^ActivationMirror reflecting: thread suspendedActivation thread: thread
)
public terminate ^<ThreadMirror> = (
	thread terminate.
)
) : (
)
public class ClosureMirror  reflecting: c <Closure> = (
    |
    public reflectee <Closure> = c.
    definingActivation <Activation> = definingActivationOf: c.
    |
    reflectees at: self put: c.
) (
public = other ^<Boolean> = (
	(is: reflectee identicalTo: other reflectee) ifFalse: [^false].
	^other isKindOfClosureMirror
)
public hash ^<Integer> = (
	^(identityHashOf: reflectee) hash bitXor: class hash
)
public isDead ^ <Boolean> = (
  ^definingActivation isDead
)
public isKindOfClosureMirror ^<Boolean> = (
	^true
)
public source ^<String> = (
 (* Crdue approximation. Need to find how to narrow it to the actual closure source *)
	^(definingActivationOf: reflectee) method source
)
public definingMethod ^ <MethodMirror>  = (
 (* can the defining activation be nil? *)
  ^MethodMirror reflecting: (definingActivationOf: reflectee) method
)
public receiver ^ <ObjectMirror> = (
  ^ObjectMirror reflecting: definingActivation receiver
)
) : (
)
public class LazySlotMirror reflecting: m <Symbol> in: em <MixinMirror> =  (
(* The mirror for a particular lazy slot. Every lazy slot consist of an underlying storage location (the cache) and 2-3 methods: 

a. The getter, which tests if the slot is nil, and if so, calls the init method (see (b) below) to compute the value and set the underlying storage. In any case it returns the value stored in the slot.  This method is sometimes referred to as the the main method of the lazy slot.

b. The init method, in charge of doing the actual computation. 

c. If the slot is mutable, there will be a third method, which is an ordinary setter.  
*)
|
    reflectee  <Symbol> = m.
	enclosingMixinMirror <MixinMirror>  = em.
	public mainMethod <MethodMirror> = MethodMirror reflecting: (mixin _methods select: [:mtd | mtd selector = m]) first.
|
) (
public accessModifier ^<Symbol> = (
	^mainMethod accessModifier.
)
public category ^<Symbol> = (
	^class lazySlotsCategory
)
public enclosingMixin = (
	^enclosingMixinMirror reflectee
)
public initMethodName = (
	^intermediates IntermediateLazySlot initMethodNameForLazySlotNamed: name.
)
public isExpression ^<Boolean> = (
	^false.
)
public isKindOfLazySlotMirror = (
	^true
)
public name ^<Symbol> = (
	^reflectee.
)
public setCachedValueFor: anObjectMirror <ObjectMirror> to: newValue <Object> ^<ObjectMirror> = (
	^anObjectMirror setSlot: cacheSlotName to: newValue.
)
parseMetadata ^ <MetadataParser> = (
    |
    src <String> = source copyFrom: 1 to: (source indexOf: '=' startingAt: 1) - 1. 
    metadataParser <MetadataParser> = metadataParsing MetadataParser onSource: src.
    |
    metadataParser gatherMetadataBackwards.
    ^metadataParser
)
public metadata ^ <Map[String, String]> = (
  ^parseMetadata metadata
)
public cachedValueFor: anObjectMirror <ObjectMirror> ^ <ObjectMirror> = (
	^anObjectMirror getSlot: cacheSlotName.
)
private mixin ^ <Mixin> = (
	^reflectees at: enclosingMixinMirror
)
public simpleName ^ <Symbol> = (
	^name
)
public selectors ^ <List[Symbol]> = (
  ^initMethod selectors (* probably need to add reflectee, and remove initMethod name *)
)
cacheSlotName ^ <Symbol> = (
	^intermediates IntermediateLazySlot slotNameForLazySlotNamed: name
)
public isMutable ^ <Boolean> = ( (* What ensures an unrelated method of this name is not created *)
  ^ (mixin _methods select: [:mtd | mtd selector = (name, ':')]) isEmpty not
)
public definingMixin ^ <MixinMirror> = (
	^enclosingMixinMirror
)
public rangeFromLazySlotExpressionToMethod: aRange = (
	| parser tsAST methodAST returnAST offset returnSpace isReturning|
	parser:: parsing Parser new.

	tsAST:: parser lazySlotDecl parseString: source asString.

	methodAST:: parser methodDecl parseString: initMethod getSource asString.
	returnAST:: methodAST body statements first.

	offset:: tsAST initializer start  - returnAST expression start.
	isReturning:: (aRange first = returnAST start).
	returnSpace:: isReturning
				 ifTrue: [ returnAST expression start - returnAST start ]
				 ifFalse: [0].

	^(aRange first + offset + returnSpace) to: (aRange last + offset).
)
private initMethod = (
	^MethodMirror reflecting: (mixin _methods select: [:mtd <Method> | mtd selector = initMethodName]) first
)
public source ^ <String> = (
	^mainMethod source
)
public hash ^ <Integer> = (
	^mainMethod hash
)
public = other = (
	^other isKindOfLazySlotMirror
		and: [mainMethod = other mainMethod]
)
) : (
public lazySlotsCategory = (
	^#'lazyslots'
)
)
public class LazySlotBuilder  reflecting: ir <IntermediateLazySlot> in: mb <MixinBuilder> = (|
	public prvtIntermediate <IntermediateLazySlot> = ir.
	prvtMixinBuilder <MixinBuilder> = mb.
|) (
public source ^<String> = (
	^prvtIntermediate  source.
)
public name = (
	^prvtIntermediate name
)
public accessModifer ^ <Symbol> = (
  ^prvtIntermediate intermediateMainMethod accessModifier
)
public isMutable ^ <Boolean> = (
  ^prvtIntermediate isMutable
)
public initMethodName = (
	^intermediates IntermediateLazySlot initMethodNameForLazySlotNamed: name.
)
public definingMixin ^ <MixinBuilder> = (
	^prvtMixinBuilder
)
) : (
)
public class LazySlotActivationMirror reflecting: a <Activation> thread: t <Thread> = ActivationMirror reflecting: a thread: t  (
(*
Mirror for the activation of a lazy slot. It takes care of computing the right sender, providing the current sourceRange considering the particular grammar , providing access to compiling the lazy slot code etc

*)
) (
public compile: newSource ifFail: onFail ^<Mirror> = (
	[ | builder newMB |
	builder:: MixinBuilder reflecting: definingMixin reflectee.
	newMB:: builder lazySlots addFromSource: newSource.
 	builder declaration install.
	^definingMixin lazySlots findMirrorNamed: newMB simpleName.		]
		on: Error
		do: [:ex | ^onFail value: ex description].
)
computeSender = (
	| lowLevelSender |
	lowLevelSender:: lowLevelActivationMirror sender sender. (* the first sender skips the main method for the lazy slot. It should not show in the debugger *)
	lowLevelSender ifNil: [ ^nil].
	^threadMirror activationFromLowLevelActivation: lowLevelSender.
)
public localNamesWithValuesDo: action <[:String :ObjectMirror]> = (
	(* lazy slots do not have local variables (temp or parameters) . It's just an expression*)
	^{}
)
public method = (
	^definingMixin lazySlots findMirrorNamed: name.
)
public name = (
	^lowLevelActivationMirror sender selector.
)
public selectorForParsing = (
	^#lazySlotDecl
)
public sourceAvailable = (
	^true.
)
public sourceRange ^ <Interval> = (
	| methodRange |

	methodRange:: lowLevelActivationMirror sourceRangeIn: threadMirror lowLevelThreadMirror.
	methodRange ifNil: [ ^nil].
	^method rangeFromLazySlotExpressionToMethod: methodRange.
)
) : (
public handleActivation: aLowLevelActivation <AcivationMirror> whenCreated: createdBlock whenContextUpdated: contextUpdatedBlock on: aThreadMirror = (
	| isMainMethod mixinMirror tsMirror methodName isCachedValueEmpty newActivation |
	methodName:: aLowLevelActivation method name.
	mixinMirror:: aLowLevelActivation method definingMixin.
	isMainMethod:: mixinMirror lazySlots includesMirrorNamed: methodName.

	(* setter *)
	(methodName endsWith: ':') ifTrue:
	[
		newActivation:: aThreadMirror lowLevelThreadMirror complete: aLowLevelActivation.
		^contextUpdatedBlock value: newActivation.
	].

	(* getter *)
	isMainMethod
		ifTrue: [
			tsMirror:: mixinMirror lazySlots findMirrorNamed: methodName.
			isCachedValueEmpty:: (aLowLevelActivation receiver getLazySlot: methodName) reflectee isNil.
			newActivation::	isCachedValueEmpty
				 ifTrue: [ aThreadMirror lowLevelThreadMirror step: aLowLevelActivation untilReturnOrMethodOnTopNamed: tsMirror initMethodName ]
				ifFalse: [ aThreadMirror lowLevelThreadMirror complete: aLowLevelActivation].

			^contextUpdatedBlock value: newActivation]
		ifFalse: [
				^createdBlock value: (self on: aLowLevelActivation thread: aThreadMirror) 	].
)
public handles: aLowLevelActivation <ActivationMirror> = (
	| mixinMirror |

	mixinMirror:: aLowLevelActivation method definingMixin.
	^mixinMirror isMethodMirrorForLazySlot: aLowLevelActivation method.
)
)
private class LazyMutableSlotGroup fromIntermediate: ir <IntermediateMixin> = Collection (|
private intermediate <IntermediateMixin> = ir.
|) (
protected newForCollectUsingAdd: capacity = (
	^List new: capacity
)
public do: action = (
	intermediate slots do:
		[:intermediateSlot |
		action value: (LazySlotMirror
			reflecting: intermediateSlot name
			in: intermediate builder)].
)
public removeMirrorNamed: name <Symbol> = (
	intermediate lazySlots removeAllSuchThat:
		[:iSlot <IntermediateLazySlot> | iSlot name = name].
)
public removeMirror: m <LazySlotMirror> = (
	intermediate lazySlots removeAllSuchThat:
		[:iSlot <IntermediateLazySlot> | iSlot name = m name].
    m delete
)
public addFromSource: source <String> = (
	|
	iSlot <IntermediateLazySlot>
	|
	iSlot:: compiler
		compileLazySlotSource: source
		within: intermediate builder.

	intermediate checkNameConflictsForLazySlot: iSlot name mutable: iSlot isMutable.

	intermediate lazySlots removeAllSuchThat:
		[:ea | ea name = iSlot name].
	intermediate lazySlots add: iSlot.

	^LazySlotBuilder reflecting: iSlot in: intermediate builder
)
) : (
)
private allInstancesOf: cls = (
	(* :literalmessage: primitive: 96 *)
	halt.
)
private allocate: cls = (
	(* :literalmessage: primitive: 34 *)
	halt.
)
buildIntermediateFor: mixin <InstanceMixin> within: ec <ICD> ^<IntermediateClassDeclaration> = (
	| i = intermediates IntermediateClassDeclaration new. |
	i simpleName: mixin _name.
	i headerSource: mixin _headerSource.
	i factoryName: mixin _primaryFactorySelector.
	i comment: nil.
	i category: 42.
	i enclosingClass: ec.
	i existingMixin: mixin.
	buildIntermediate: i instanceSide from: mixin within: i.
	buildIntermediate: i classSide from: mixin _classMixin within: i.
	^i
)
private classOf: object = (
	(* :literalmessage: primitive: 85 *)
	halt.
)
public compiler = (
	nil = compilerX ifTrue: [constructCompiler].
	^compilerX
)
private copiedOf: closure <Closure> at: index <Integer> ^<Object> = (
	(* :literalmessage: primitive: 77 *)
	halt.
)
private copiedOf: closure <Closure> at: index <Integer> put: value <Object> ^<Object> = (
	(* :literalmessage: primitive: 78 *)
	halt.
)
private currentActivation ^<Activation> (* :no_exemplars: *) = (
	(* :literalmessage: primitive: 133 *)
	halt.
)
private definingActivationOf: closure <Closure> ^<Activation> = (
	(* :literalmessage: primitive: 71 *)
	halt.
)
private elementsOf: old forwardIdentityToElementsOf: new = (
	(* :literalmessage: primitive: 98 *)
	halt.
)
private enclosingObjectOf: behavior = (
	^self slotOf: behavior at: 3
)
private formatOf: behavior = (
	^self slotOf: behavior at: 6
)
private identityHashOf: a = (
	(* :literalmessage: primitive: 87 *)
	halt.
)
private initialBCIOf: closure <Closure> ^<Integer> = (
	(* :literalmessage: primitive: 73 *)
	halt.
)
public installer ^ <AtomicInstallWrapper> = (
  ^AtomicInstallWrapper new
)
private intermediates = (
	nil = intermediatesX ifTrue: [constructCompiler].
	^intermediatesX
)
private is: a identicalTo: b = (
	(* :literalmessage: primitive: 86 *)
	halt.
)
private isBehavior: object = (
	| cls |
	cls:: classOf: object.
	Metaclass = cls ifTrue: [^true (* [object] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifTrue: [^true (* [object] is a class *)].
	cls:: classOf: cls.
	assert: [Metaclass = cls] message: ''.
	^false
)
private isSubinitializerSelector: selector = (
	(selector startsWith: 'mixinInitializer`') ifTrue: [^true].
	(selector startsWith: 'initializer`') ifTrue: [^true].
	^false
)
private isSyntheticSlotSelector: selector = (
	^selector endsWith: '`slot'
)
private methodsOf: behavior = (
	^self slotOf: behavior at: 2
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private numCopiedOf: closure <Closure> ^<Integer> = (
	(* :literalmessage: primitive: 70 *)
	halt.
)
private parsing = (
	nil = parsingX ifTrue: [constructCompiler].
	^parsingX
)
private slotOf: object at: index = (
	(* :literalmessage: primitive: 35 *)
	halt.
)
private slotOf: object at: index put: value = (
	(* :literalmessage: primitive: 36 *)
	halt.
)
private subclassesOf: klass = (
	^self slotOf: klass at: 8
)
private superclassOf: behavior = (
	^self slotOf: behavior at: 1
)
private constructCompiler = (
	| asts compilation |
	asts:: namespace NewspeakASTs
		usingPlatform: cachedPlatform.
	parsingX:: namespace NewspeakPredictiveParsing
		usingPlatform: cachedPlatform
		asts: asts.
	intermediatesX:: namespace Intermediates
		usingPlatform: cachedPlatform
		internalKernel: internalKernel.
	compilation:: namespace Newspeak2PrimordialSoupCompilation
		usingPlatform: cachedPlatform
		asts: asts
		newspeakParser: parsingX
		intermediates: intermediatesX.
	compilerX:: compilation Compiler new.
)
buildIntermediate: i <IntermediateMixin> from: mixin <AbstractMixin> within: ec = (
	| 
    initializers = List new.  
    lazySlotGetters <Map[Symbol, IntermediateMethod]> = Map new.  
    lazySlotInits <Map[Symbol, IntermediateMethod]> = Map new. 
    lazySlotSetters <Map[Symbol, IntermediateMethod]> = Map new.
    |

	mixin _methods do:
		[:method <Method> |
		|
		selector <Symbol> = method selector.
		imethod <IntermediateMethod> = intermediates IntermediateMethod new.
		|
		imethod method: method.
		imethod methodMixin: mixin.
		imethod selector: selector.
		imethod accessModifier: method accessModifier.
		imethod isSynthetic: method isSynthetic.
		imethod source: method source.
		(isSubinitializerSelector: selector) ifTrue:
			[initializers add: imethod].
        method isLazySlotMethod ifTrue: [
          | ls <Symbol> = lazySlotNameFromMethod: method. |
          imethod isLazySlotMethod: true.
          selector = ls 
            ifTrue: [lazySlotGetters at: ls put: imethod]
            ifFalse: [(selector indexOf: '`method') ~= 0
              ifTrue: [lazySlotInits at: ls put: imethod]  
              ifFalse: [lazySlotSetters at: ls put: imethod.]
              ]
          ].
		imethod isSynthetic ifFalse:
			[i methods add: imethod]
        ].
    lazySlotGetters do: [:lg <IntermediateMethod> |
      | 
      lazySlot <IntermediateLazySlot> = intermediates IntermediateLazySlot new. 
      s <Symbol> = lg selector.
      |
      lazySlot 
           intermediateMainMethod: lg; 
           intermediateInitMethod: (lazySlotInits at: s);
           intermediateSetterMethod: (lazySlotSetters at: s ifAbsent: []). 
       i lazySlots add: lazySlot.
    ].
	mixin isMeta ifTrue:
		[ | factoryName <Symbol> factoryM <Method>  factoryIR <IntermediateMethod> |
		factoryName:: mixin _instanceMixin _primaryFactorySelector.
		factoryM:: mixin _methods detect: [:ea | ea selector = factoryName].
		factoryIR:: intermediates IntermediateMethod new.
		factoryIR method: factoryM.
		factoryIR methodMixin: mixin.
		factoryIR selector: factoryName.
		factoryIR accessModifier: factoryM accessModifier.
		factoryIR isSynthetic: true.
		i declaration factory: factoryIR.
		^self].

	i declaration initializers: initializers.

	mixin _slots do:
		[:tuple <{Symbol. Boolean. Symbol}> |
		| slot <IntermediateSlotDeclaration> = intermediates IntermediateSlotDeclaration new. |
		slot name: (tuple at: 1).
		slot isMutable: (tuple at: 2).
		slot accessModifier: (tuple at: 3).
		(isSyntheticSlotSelector: slot name) ifFalse:
			[i slots add: slot]].

	mixin _nestedMixins do:
		[:nestedMixin <InstanceMixin> |
		|
		nestedIR <IntermediateClassDeclaration>
		accessorM <Method>
		accessorIR <IntermediateMethod>
		|
		nestedIR:: buildIntermediateFor: nestedMixin within: ec.
		i nestedClasses add: nestedIR.

		accessorM:: mixin _methods detect: [:ea | ea selector = nestedIR simpleName].
		accessorIR:: intermediates IntermediateMethod new.
		accessorIR method: accessorM.
		accessorIR methodMixin: mixin.
		accessorIR selector: nestedIR simpleName.
		accessorIR accessModifier: accessorM accessModifier.
		accessorIR isSynthetic: true.
		nestedIR accessor: accessorIR].
)
lazySlotNameFromMethod: m <Method> ^ <Symbol> = (
  | i <Integer> = m selector indexOf: '`'. j <Integer> = m selector indexOf: ':'. |
  assert: m isLazySlotMethod message: 'Attempt to view non-lazy slot method ', m selector, ' as lazy slot method'.
  j = 0 ifTrue: [
    i = 0 ifTrue: [^m selector].
    ^m selector copyFrom: 1 to: i - 1
    ].
  ^m selector copyFrom: 1 to: j -1.
)
) : (
)
